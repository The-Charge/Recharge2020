// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.Servo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Turret extends Subsystem {
    private static final double H_DEGREES_PER_TICK = 0.0;  // how many degrees traveled per encoder tick
    private static final double H_TICKS_PER_DEGREE = 1 / H_DEGREES_PER_TICK;
    private static final int H_MIN_ENCODER_TICKS = 5000;  // used to stop turret from rotating past ends
    private static final int H_MAX_ENCODER_TICKS = -H_MIN_ENCODER_TICKS;
    private static final double H_MIN_ANGLE = H_MIN_ENCODER_TICKS * H_DEGREES_PER_TICK;
    private static final double H_MAX_ANGLE = H_MAX_ENCODER_TICKS * H_DEGREES_PER_TICK;
    private static final double H_TOLERANCE = 5;

    //Constants aquired from CAD team used for trig calculations (millimeters):
    public static final double TURRET_SIDE_A = 244.475;
    public static final double TURRET_SIDE_B = 369.4176;
    private final double V_MIN_ANGLE = 34.4;
    private final double V_MAX_ANGLE = 57.4;
    private final double V_TOLERANCE = 0.01;

    private double actuatorDistance;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX turretMotor;
    private Servo elevationServo;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public Turret() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        turretMotor = new WPI_TalonSRX(9);
        elevationServo = new Servo(0);
        addChild("ElevationServo", elevationServo);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // turretMotor.set(ControlMode.Position, 0);
        turretMotor.setSelectedSensorPosition(0);
        turretMotor.setNeutralMode(NeutralMode.Brake);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new RunTurretManual());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }

    @Override
    public void periodic() {}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    private void setHorizontalAngleAbsolute(double setpoint) {
        double ticks = turretMotor.getSelectedSensorPosition();
        if ((setpoint < H_MIN_ANGLE || setpoint > H_MAX_ANGLE) || (ticks < H_MIN_ENCODER_TICKS || ticks > H_MAX_ENCODER_TICKS)) {
            stopHorizontal();
        } else {
            turretMotor.set(ControlMode.Position, setpoint * H_TICKS_PER_DEGREE);
        }
        // other teams used a rate limiter to stabilize the setpoint
    }

    private double calcActuatorDistance(double angle) {
        double d = Math.sqrt(Math.pow(Turret.TURRET_SIDE_A, 2) + Math.pow(Turret.TURRET_SIDE_B, 2) - 2 * Turret.TURRET_SIDE_A * Turret.TURRET_SIDE_B * Math.cos(Math.toRadians(94.4 - angle)));
        d -= 218;
        d /= 140;
        return d;
    }

    public void setVerticalAngle(double setpoint) {
        if(setpoint > V_MAX_ANGLE) {
            setpoint = V_MAX_ANGLE;
        } else if(setpoint < V_MIN_ANGLE) {
            setpoint = V_MIN_ANGLE;
        }
        
        actuatorDistance = calcActuatorDistance(setpoint);
        elevationServo.set(actuatorDistance);
    }

    public boolean atVerticalAngle(double angle) {
        return (Math.abs(elevationServo.get() - calcActuatorDistance(angle)) <= V_TOLERANCE);
    }

    public void stopHorizontal() {
        turretMotor.set(ControlMode.PercentOutput, 0);
    }

    private double getHorizontalAngle() {
        return turretMotor.getSelectedSensorPosition() * H_DEGREES_PER_TICK;
    }

    public boolean atHorizontalAngle(double angle) {
        double current = getHorizontalAngle();
        return (angle - H_TOLERANCE < current) && (current < angle + H_TOLERANCE);
    }

	public void setHorizontalAngleRelative(double setpoint) {
        setHorizontalAngleAbsolute(setpoint + getHorizontalAngle());
    }

	public Servo getElevationServo() {
        return elevationServo;
    }
    
    public void runManual(double percent) {
        int ticks = turretMotor.getSelectedSensorPosition();
        if ((ticks < H_MIN_ENCODER_TICKS && percent < 0) || (ticks > H_MAX_ENCODER_TICKS && percent > 0)) {
            stopHorizontal();
        } else {
            turretMotor.set(ControlMode.PercentOutput, percent);
        }
    }
}


// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpiutil.math.MathUtil;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.Solenoid;

import com.ctre.phoenix.motorcontrol.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class AngleElevation extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
private WPI_TalonSRX angleElevationMotor;
private Solenoid brakes;  //CHECK
public static final int MIN_ENCODER_TICKS = 0;   //these values need to be tuned
public static final int MAX_ENCODER_TICKS = 5000;

private final static double SPEED_P_CONSTANT = 1;
private final static double SPEED_I_CONSTANT = 0.001;
private final static double SPEED_D_CONSTANT = 0.0;
private final static double SPEED_F_CONSTANT = 10;

private final static int MAX_TICKS_PER_SEC = 934;
private final static int TICKS_TO_TOP = 28000;
private final static int TICKS_TO_BOTTOM = 0;
private double MotionMagicDistance;

final int TIMEOUT_MS = 10;    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public AngleElevation() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        brakes = new Solenoid(0, 5); //CHECK
        addChild("Brakes",brakes); //CHECK
angleElevationMotor = new WPI_TalonSRX(11);


        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }
    
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void runManual(double percent)
    {
        int angle = angleElevationMotor.getSelectedSensorPosition();
        if ((angle < MIN_ENCODER_TICKS && percent < 0) || (angle > MAX_ENCODER_TICKS))
            stop();
        else
            angleElevationMotor.set(ControlMode.Velocity, MAX_TICKS_PER_SEC * percent );
    }

    public void stop()
    {
        angleElevationMotor.set(ControlMode.Velocity, 0);
        angleElevationMotor.disable();
        brakeOn();//CHECK
    }

    public void brakeOn()
    {
        brakes.set(false);  //CHECK
    }
    public void brakeOff()
    {
        brakes.set(true);
    }

    public void MotionMagicInit(double percentDistance)
    {
        percentDistance = MathUtil.clamp(percentDistance, -0.1, 1);
        MotionMagicDistance *= TICKS_TO_TOP - TICKS_TO_BOTTOM;
        MotionMagicDistance += TICKS_TO_BOTTOM;
    }

    public boolean isAtPIDDestination()
    {
        angleElevationMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, TIMEOUT_MS);
        double error = Math.abs(getPIDError());
        return false; //temporary value return
    }
public double getPIDError()
{
    return getTicks() - getTarget();
}

    public double getTicks()
    {
        return angleElevationMotor.getSelectedSensorPosition();
    }
    public double getTarget()
    {
        return MotionMagicDistance;
    }
}

